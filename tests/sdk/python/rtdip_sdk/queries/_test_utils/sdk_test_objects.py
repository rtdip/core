# Copyright 2022 RTDIP
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

SERVER_HOSTNAME = "mock.cloud.databricks.com"
HTTP_PATH = "sql/mock/mock-test"
ACCESS_TOKEN = "mock_databricks_token"
DATABRICKS_SQL_CONNECT = "databricks.sql.connect"
DATABRICKS_SQL_CONNECT_CURSOR = "databricks.sql.connect.cursor"

MOCKED_PARAMETER_DICT = {
    "business_unit": "mocked-buiness-unit",
    "region": "mocked-region",
    "asset": "mocked-asset",
    "data_security_level": "mocked-data-security-level",
    "data_type": "mocked-data-type",
    "tag_names": ["mocked-TAGNAME"],
    "start_date": "2011-01-01",
    "end_date": "2011-01-02",
    "include_bad_data": True,
}

MOCKED_QUERY_OFFSET_LIMIT = "LIMIT 10 OFFSET 10 "

# Raw
RAW_MOCKED_QUERY = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME') ORDER BY `TagName`, `EventTime`) SELECT * FROM raw"
RAW_MOCKED_QUERY_CHECK_TAGS = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND UPPER(`TagName`) IN ('MOCKED-TAGNAME') ORDER BY `TagName`, `EventTime`) SELECT * FROM raw"
RAW_MOCKED_QUERY_DISPLAY_UOM = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME') ORDER BY `TagName`, `EventTime`), uom AS (SELECT raw.*, metadata.`UoM` FROM raw LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` AS metadata ON raw.`TagName` = metadata.`TagName`) SELECT * FROM uom"

# Resample
RESAMPLE_MOCKED_QUERY = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND `TagName` IN ('mocked-TAGNAME')), resample AS (SELECT raw.`TagName`, raw.`window`.start AS `EventTime`, avg(raw.`Value`) AS `Value` FROM raw GROUP BY raw.`TagName`, raw.`window`.start ORDER BY `TagName`, `EventTime`) SELECT * FROM resample"
RESAMPLE_MOCKED_QUERY_CHECK_TAGS = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND UPPER(`TagName`) IN ('MOCKED-TAGNAME')), resample AS (SELECT raw.`TagName`, raw.`window`.start AS `EventTime`, avg(raw.`Value`) AS `Value` FROM raw GROUP BY raw.`TagName`, raw.`window`.start ORDER BY `TagName`, `EventTime`) SELECT * FROM resample"
RESAMPLE_MOCKED_QUERY_PIVOT = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND `TagName` IN ('mocked-TAGNAME')), resample AS (SELECT raw.`TagName`, raw.`window`.start AS `EventTime`, avg(raw.`Value`) AS `Value` FROM raw GROUP BY raw.`TagName`, raw.`window`.start), pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` FROM resample) PIVOT (FIRST(`Value`) FOR `TagName` IN ('mocked-TAGNAME' AS `mocked-TAGNAME`)) ORDER BY `EventTime`) SELECT * FROM pivot"
RESAMPLE_MOCKED_QUERY_UOM = "WITH raw AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND `TagName` IN ('mocked-TAGNAME')), resample AS (SELECT raw.`TagName`, raw.`window`.start AS `EventTime`, avg(raw.`Value`) AS `Value` FROM raw GROUP BY raw.`TagName`, raw.`window`.start ORDER BY `TagName`, `EventTime`), uom AS (SELECT resample.*, metadata.`UoM` FROM resample LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` AS metadata ON resample.`TagName` = metadata.`TagName`) SELECT * FROM uom"

# Plot
PLOT_MOCKED_QUERY = "WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME')), date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS timestamp_array), window_buckets AS (SELECT timestamp_array AS window_start, timestampadd(minute, 15, timestamp_array) AS window_end FROM date_array), plot AS (SELECT /*+ RANGE_JOIN(d, 900) */ d.window_start, d.window_end, e.`TagName`, min(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `min_Value`, max(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `max_Value`, first(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `first_Value`, last(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `last_Value`, first(CASE WHEN `Status` = 'Bad' THEN struct(e.`Value`, e.`EventTime`) ELSE null END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `excp_Value` FROM window_buckets d INNER JOIN raw_events e ON d.window_start <= e.`EventTime` AND d.window_end > e.`EventTime`), deduplicate AS (SELECT window_start AS `EventTime`, `TagName`, `min_Value` as `Min`, `max_Value` as `Max`, `first_Value` as `First`, `last_Value` as `Last`, `excp_Value` as `Exception` FROM plot GROUP BY window_start, `TagName`, `min_Value`, `max_Value`, `first_Value`, `last_Value`, `excp_Value`), project AS (SELECT distinct Values.EventTime, `TagName`, Values.Value FROM (SELECT * FROM deduplicate UNPIVOT (`Values` for `Aggregation` IN (`Min`, `Max`, `First`, `Last`, `Exception`))) ORDER BY `TagName`, `EventTime`) SELECT * FROM project"
PLOT_MOCKED_QUERY_CHECK_TAGS = "WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND UPPER(`TagName`) IN ('MOCKED-TAGNAME')), date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS timestamp_array), window_buckets AS (SELECT timestamp_array AS window_start, timestampadd(minute, 15, timestamp_array) AS window_end FROM date_array), plot AS (SELECT /*+ RANGE_JOIN(d, 900) */ d.window_start, d.window_end, e.`TagName`, min(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `min_Value`, max(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `max_Value`, first(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `first_Value`, last(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `last_Value`, first(CASE WHEN `Status` = 'Bad' THEN struct(e.`Value`, e.`EventTime`) ELSE null END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `excp_Value` FROM window_buckets d INNER JOIN raw_events e ON d.window_start <= e.`EventTime` AND d.window_end > e.`EventTime`), deduplicate AS (SELECT window_start AS `EventTime`, `TagName`, `min_Value` as `Min`, `max_Value` as `Max`, `first_Value` as `First`, `last_Value` as `Last`, `excp_Value` as `Exception` FROM plot GROUP BY window_start, `TagName`, `min_Value`, `max_Value`, `first_Value`, `last_Value`, `excp_Value`), project AS (SELECT distinct Values.EventTime, `TagName`, Values.Value FROM (SELECT * FROM deduplicate UNPIVOT (`Values` for `Aggregation` IN (`Min`, `Max`, `First`, `Last`, `Exception`))) ORDER BY `TagName`, `EventTime`) SELECT * FROM project"
PLOT_MOCKED_QUERY_PIVOT = "WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME')), date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS timestamp_array), window_buckets AS (SELECT timestamp_array AS window_start, timestampadd(minute, 15, timestamp_array) AS window_end FROM date_array), plot AS (SELECT /*+ RANGE_JOIN(d, 900) */ d.window_start, d.window_end, e.`TagName`, min(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `min_Value`, max(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `max_Value`, first(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `first_Value`, last(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `last_Value`, first(CASE WHEN `Status` = 'Bad' THEN struct(e.`Value`, e.`EventTime`) ELSE null END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `excp_Value` FROM window_buckets d INNER JOIN raw_events e ON d.window_start <= e.`EventTime` AND d.window_end > e.`EventTime`), deduplicate AS (SELECT window_start AS `EventTime`, `TagName`, `min_Value` as `Min`, `max_Value` as `Max`, `first_Value` as `First`, `last_Value` as `Last`, `excp_Value` as `Exception` FROM plot GROUP BY window_start, `TagName`, `min_Value`, `max_Value`, `first_Value`, `last_Value`, `excp_Value`), project AS (SELECT distinct Values.EventTime, `TagName`, Values.Value FROM (SELECT * FROM deduplicate UNPIVOT (`Values` for `Aggregation` IN (`Min`, `Max`, `First`, `Last`, `Exception`)))), pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` FROM project) PIVOT (FIRST(`Value`) FOR `TagName` IN ('mocked-TAGNAME' AS `mocked-TAGNAME`)) ORDER BY `EventTime`) SELECT * FROM pivot"
PLOT_MOCKED_QUERY_UOM = "WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME')), date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS timestamp_array), window_buckets AS (SELECT timestamp_array AS window_start, timestampadd(minute, 15, timestamp_array) AS window_end FROM date_array), plot AS (SELECT /*+ RANGE_JOIN(d, 900) */ d.window_start, d.window_end, e.`TagName`, min(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `min_Value`, max(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `max_Value`, first(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `first_Value`, last(CASE WHEN `Status` = 'Bad' THEN null ELSE struct(e.`Value`, e.`EventTime`) END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `last_Value`, first(CASE WHEN `Status` = 'Bad' THEN struct(e.`Value`, e.`EventTime`) ELSE null END, True) OVER (PARTITION BY e.`TagName`, d.window_start ORDER BY e.`EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS `excp_Value` FROM window_buckets d INNER JOIN raw_events e ON d.window_start <= e.`EventTime` AND d.window_end > e.`EventTime`), deduplicate AS (SELECT window_start AS `EventTime`, `TagName`, `min_Value` as `Min`, `max_Value` as `Max`, `first_Value` as `First`, `last_Value` as `Last`, `excp_Value` as `Exception` FROM plot GROUP BY window_start, `TagName`, `min_Value`, `max_Value`, `first_Value`, `last_Value`, `excp_Value`), project AS (SELECT distinct Values.EventTime, `TagName`, Values.Value FROM (SELECT * FROM deduplicate UNPIVOT (`Values` for `Aggregation` IN (`Min`, `Max`, `First`, `Last`, `Exception`))) ORDER BY `TagName`, `EventTime`), uom AS (SELECT project.*, metadata.`UoM` FROM project LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` AS metadata ON project.`TagName` = metadata.`TagName`) SELECT * FROM uom"

# Interpolate
INTERPOLATE_MOCKED_QUERY = "WITH raw AS (SELECT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND `TagName` IN ('mocked-TAGNAME')), intervals AS (SELECT DISTINCT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS `EventTime`, explode(array('mocked-TAGNAME')) AS `TagName`), fill_intervals as (SELECT intervals.`TagName`, intervals.`EventTime` as `EventTime`, raw. `EventTime` as `OriginalEventTime`, raw.`Value`, CASE WHEN raw.`Value` IS NULL THEN NULL ELSE struct(raw.`EventTime`, raw.`Value`) END AS `EventTime_Value` FROM intervals LEFT OUTER JOIN raw ON intervals.`EventTime` = raw.`window`.start AND intervals.`TagName` = raw.`TagName`), interpolate_calculate AS (SELECT `OriginalEventTime`, `EventTime`, `TagName`, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LAG(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS PrevEventTimeValue, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LEAD(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS NextEventTimeValue, CASE WHEN `OriginalEventTime` = `EventTime` THEN `Value` WHEN `PrevEventTimeValue` IS NOT NULL AND `NextEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` + ((`NextEventTimeValue`.`Value` - `PrevEventTimeValue`.`Value`) * (unix_timestamp(`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`)) / (unix_timestamp(`NextEventTimeValue`.`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`))) WHEN `PrevEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` ELSE NULL END as `Value` FROM fill_intervals ), interpolate AS (SELECT `EventTime`, `TagName`, `Value` FROM interpolate_calculate WHERE `OriginalEventTime` IS NULL OR `OriginalEventTime` = `EventTime`  ORDER BY `TagName`, `EventTime`) SELECT * FROM interpolate"
INTERPOLATE_MOCKED_QUERY_CHECK_TAGS = "WITH raw AS (SELECT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND UPPER(`TagName`) IN ('MOCKED-TAGNAME')), intervals AS (SELECT DISTINCT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS `EventTime`, explode(array('MOCKED-TAGNAME')) AS `TagName`), fill_intervals as (SELECT intervals.`TagName`, intervals.`EventTime` as `EventTime`, raw. `EventTime` as `OriginalEventTime`, raw.`Value`, CASE WHEN raw.`Value` IS NULL THEN NULL ELSE struct(raw.`EventTime`, raw.`Value`) END AS `EventTime_Value` FROM intervals LEFT OUTER JOIN raw ON intervals.`EventTime` = raw.`window`.start AND intervals.`TagName` = raw.`TagName`), interpolate_calculate AS (SELECT `OriginalEventTime`, `EventTime`, `TagName`, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LAG(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS PrevEventTimeValue, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LEAD(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS NextEventTimeValue, CASE WHEN `OriginalEventTime` = `EventTime` THEN `Value` WHEN `PrevEventTimeValue` IS NOT NULL AND `NextEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` + ((`NextEventTimeValue`.`Value` - `PrevEventTimeValue`.`Value`) * (unix_timestamp(`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`)) / (unix_timestamp(`NextEventTimeValue`.`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`))) WHEN `PrevEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` ELSE NULL END as `Value` FROM fill_intervals ), interpolate AS (SELECT `EventTime`, `TagName`, `Value` FROM interpolate_calculate WHERE `OriginalEventTime` IS NULL OR `OriginalEventTime` = `EventTime`  ORDER BY `TagName`, `EventTime`) SELECT * FROM interpolate"
INTERPOLATE_MOCKED_QUERY_PIVOT = "WITH raw AS (SELECT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND `TagName` IN ('mocked-TAGNAME')), intervals AS (SELECT DISTINCT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS `EventTime`, explode(array('mocked-TAGNAME')) AS `TagName`), fill_intervals as (SELECT intervals.`TagName`, intervals.`EventTime` as `EventTime`, raw. `EventTime` as `OriginalEventTime`, raw.`Value`, CASE WHEN raw.`Value` IS NULL THEN NULL ELSE struct(raw.`EventTime`, raw.`Value`) END AS `EventTime_Value` FROM intervals LEFT OUTER JOIN raw ON intervals.`EventTime` = raw.`window`.start AND intervals.`TagName` = raw.`TagName`), interpolate_calculate AS (SELECT `OriginalEventTime`, `EventTime`, `TagName`, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LAG(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS PrevEventTimeValue, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LEAD(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS NextEventTimeValue, CASE WHEN `OriginalEventTime` = `EventTime` THEN `Value` WHEN `PrevEventTimeValue` IS NOT NULL AND `NextEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` + ((`NextEventTimeValue`.`Value` - `PrevEventTimeValue`.`Value`) * (unix_timestamp(`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`)) / (unix_timestamp(`NextEventTimeValue`.`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`))) WHEN `PrevEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` ELSE NULL END as `Value` FROM fill_intervals ), interpolate AS (SELECT `EventTime`, `TagName`, `Value` FROM interpolate_calculate WHERE `OriginalEventTime` IS NULL OR `OriginalEventTime` = `EventTime` ), pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` FROM interpolate) PIVOT (FIRST(`Value`) FOR `TagName` IN ('mocked-TAGNAME' AS `mocked-TAGNAME`)) ORDER BY `EventTime`) SELECT * FROM pivot"
INTERPOLATE_MOCKED_QUERY_UOM = "WITH raw AS (SELECT from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000') AS `EventTime`, window(from_utc_timestamp(date_trunc('millisecond',`EventTime`), '+0000'), '15 minute', '15 minute', '0 second') AS `window`, `TagName`, `Status`, `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND timestampadd(minute, 15, to_timestamp('2011-01-02T23:59:59+00:00')) AND `TagName` IN ('mocked-TAGNAME')), intervals AS (SELECT DISTINCT explode(sequence(from_utc_timestamp(to_timestamp('2011-01-01T00:00:00+00:00'), '+0000'), from_utc_timestamp(to_timestamp('2011-01-02T23:59:59+00:00'), '+0000'), INTERVAL '15 minute')) AS `EventTime`, explode(array('mocked-TAGNAME')) AS `TagName`), fill_intervals as (SELECT intervals.`TagName`, intervals.`EventTime` as `EventTime`, raw. `EventTime` as `OriginalEventTime`, raw.`Value`, CASE WHEN raw.`Value` IS NULL THEN NULL ELSE struct(raw.`EventTime`, raw.`Value`) END AS `EventTime_Value` FROM intervals LEFT OUTER JOIN raw ON intervals.`EventTime` = raw.`window`.start AND intervals.`TagName` = raw.`TagName`), interpolate_calculate AS (SELECT `OriginalEventTime`, `EventTime`, `TagName`, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LAG(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS PrevEventTimeValue, CASE WHEN `Value` IS NOT NULL THEN NULL ELSE LEAD(`EventTime_Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) END AS NextEventTimeValue, CASE WHEN `OriginalEventTime` = `EventTime` THEN `Value` WHEN `PrevEventTimeValue` IS NOT NULL AND `NextEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` + ((`NextEventTimeValue`.`Value` - `PrevEventTimeValue`.`Value`) * (unix_timestamp(`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`)) / (unix_timestamp(`NextEventTimeValue`.`EventTime`) - unix_timestamp(`PrevEventTimeValue`.`EventTime`))) WHEN `PrevEventTimeValue` IS NOT NULL THEN `PrevEventTimeValue`.`Value` ELSE NULL END as `Value` FROM fill_intervals ), interpolate AS (SELECT `EventTime`, `TagName`, `Value` FROM interpolate_calculate WHERE `OriginalEventTime` IS NULL OR `OriginalEventTime` = `EventTime`  ORDER BY `TagName`, `EventTime`), uom AS (SELECT interpolate.*, metadata.`UoM` FROM interpolate LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` AS metadata ON interpolate.`TagName` = metadata.`TagName`) SELECT * FROM uom"

# Time Weighted Average
TWA_MOCKED_QUERY = 'WITH raw_events AS (SELECT DISTINCT `TagName`, from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-02T23:59:59+00:00")), 1) AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000"), from_utc_timestamp(to_timestamp("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`) ,boundary_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) ,window_buckets AS (SELECT `EventTime` AS window_start, LEAD(`EventTime`) OVER (ORDER BY `EventTime`) AS window_end FROM (SELECT distinct `EventTime` FROM date_array) ) ,window_events AS (SELECT /*+ RANGE_JOIN(b, 900 ) */ b.`TagName`, b.`EventTime`, a.window_start AS `WindowEventTime`, b.`Status`, b.`Value` FROM boundary_events b LEFT OUTER JOIN window_buckets a ON a.window_start <= b.`EventTime` AND a.window_end > b.`EventTime`) ,fill_status AS (SELECT *, last_value(`Status`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Status`, CASE WHEN `Fill_Status` <> "Bad" THEN `Value` ELSE null END AS `Good_Value` FROM window_events) ,fill_value AS (SELECT *, last_value(`Good_Value`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Value` FROM fill_status) ,fill_step AS (SELECT *, false AS Step FROM fill_value) ,interpolate AS (SELECT *, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_Fill_Value`, lead(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) AS `Next_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lead(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Next_Fill_Value`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN `Previous_Fill_Value` + ( (`Next_Fill_Value` - `Previous_Fill_Value`) * ( ( unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`) ) / ( unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`) ) ) ) ELSE NULL END AS `Interpolated_Value`, coalesce(`Interpolated_Value`, `Fill_Value`) as `Event_Value` FROM fill_step ),twa_calculations AS (SELECT `TagName`, `EventTime`, `WindowEventTime`, `Step`, `Status`, `Value`, `Previous_EventTime`, `Previous_Fill_Value`, `Next_EventTime`, `Next_Fill_Value`, `Interpolated_Value`, `Fill_Status`, `Fill_Value`, `Event_Value`, lead(`Fill_Status`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Status` , CASE WHEN `Next_Status` <> "Bad" OR (`Fill_Status` <> "Bad" AND `Next_Status` = "Bad") THEN lead(`Event_Value`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) ELSE `Value` END AS `Next_Value_For_Status` , CASE WHEN `Fill_Status` <> "Bad" THEN `Next_Value_For_Status` ELSE 0 END AS `Next_Value` , CASE WHEN `Fill_Status` <> "Bad" AND `Next_Status` <> "Bad" THEN ((cast(`Next_EventTime` AS double) - cast(`EventTime` AS double)) / 60) WHEN `Fill_Status` <> "Bad" AND `Next_Status` = "Bad" THEN ((cast(`Next_EventTime` AS integer) - cast(`EventTime` AS double)) / 60) ELSE 0 END AS good_minutes , CASE WHEN Step == false THEN ((`Event_Value` + `Next_Value`) * 0.5) * good_minutes ELSE (`Event_Value` * good_minutes) END AS twa_value FROM interpolate) ,twa AS (SELECT `TagName`, `WindowEventTime` AS `EventTime`, sum(twa_value) / sum(good_minutes) AS `Value` from twa_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT * FROM twa WHERE `EventTime` BETWEEN to_timestamp("2011-01-01T00:00:00") AND to_timestamp("2011-01-02T23:59:59")) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
TWA_MOCKED_QUERY_CHECK_TAGS = 'WITH raw_events AS (SELECT DISTINCT `TagName`, from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-02T23:59:59+00:00")), 1) AND UPPER(`TagName`) IN (\'MOCKED-TAGNAME\')  ) ,date_array AS (SELECT DISTINCT explode(sequence(from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000"), from_utc_timestamp(to_timestamp("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, explode(array(`TagName`)) AS `TagName` FROM raw_events) ,boundary_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) ,window_buckets AS (SELECT `EventTime` AS window_start, LEAD(`EventTime`) OVER (ORDER BY `EventTime`) AS window_end FROM (SELECT distinct `EventTime` FROM date_array) ) ,window_events AS (SELECT /*+ RANGE_JOIN(b, 900 ) */ b.`TagName`, b.`EventTime`, a.window_start AS `WindowEventTime`, b.`Status`, b.`Value` FROM boundary_events b LEFT OUTER JOIN window_buckets a ON a.window_start <= b.`EventTime` AND a.window_end > b.`EventTime`) ,fill_status AS (SELECT *, last_value(`Status`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Status`, CASE WHEN `Fill_Status` <> "Bad" THEN `Value` ELSE null END AS `Good_Value` FROM window_events) ,fill_value AS (SELECT *, last_value(`Good_Value`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Value` FROM fill_status) ,fill_step AS (SELECT *, false AS Step FROM fill_value) ,interpolate AS (SELECT *, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_Fill_Value`, lead(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) AS `Next_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lead(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Next_Fill_Value`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN `Previous_Fill_Value` + ( (`Next_Fill_Value` - `Previous_Fill_Value`) * ( ( unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`) ) / ( unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`) ) ) ) ELSE NULL END AS `Interpolated_Value`, coalesce(`Interpolated_Value`, `Fill_Value`) as `Event_Value` FROM fill_step ),twa_calculations AS (SELECT `TagName`, `EventTime`, `WindowEventTime`, `Step`, `Status`, `Value`, `Previous_EventTime`, `Previous_Fill_Value`, `Next_EventTime`, `Next_Fill_Value`, `Interpolated_Value`, `Fill_Status`, `Fill_Value`, `Event_Value`, lead(`Fill_Status`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Status` , CASE WHEN `Next_Status` <> "Bad" OR (`Fill_Status` <> "Bad" AND `Next_Status` = "Bad") THEN lead(`Event_Value`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) ELSE `Value` END AS `Next_Value_For_Status` , CASE WHEN `Fill_Status` <> "Bad" THEN `Next_Value_For_Status` ELSE 0 END AS `Next_Value` , CASE WHEN `Fill_Status` <> "Bad" AND `Next_Status` <> "Bad" THEN ((cast(`Next_EventTime` AS double) - cast(`EventTime` AS double)) / 60) WHEN `Fill_Status` <> "Bad" AND `Next_Status` = "Bad" THEN ((cast(`Next_EventTime` AS integer) - cast(`EventTime` AS double)) / 60) ELSE 0 END AS good_minutes , CASE WHEN Step == false THEN ((`Event_Value` + `Next_Value`) * 0.5) * good_minutes ELSE (`Event_Value` * good_minutes) END AS twa_value FROM interpolate) ,twa AS (SELECT `TagName`, `WindowEventTime` AS `EventTime`, sum(twa_value) / sum(good_minutes) AS `Value` from twa_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT * FROM twa WHERE `EventTime` BETWEEN to_timestamp("2011-01-01T00:00:00") AND to_timestamp("2011-01-02T23:59:59")) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
TWA_MOCKED_QUERY_PIVOT = 'WITH raw_events AS (SELECT DISTINCT `TagName`, from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-02T23:59:59+00:00")), 1) AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000"), from_utc_timestamp(to_timestamp("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`) ,boundary_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) ,window_buckets AS (SELECT `EventTime` AS window_start, LEAD(`EventTime`) OVER (ORDER BY `EventTime`) AS window_end FROM (SELECT distinct `EventTime` FROM date_array) ) ,window_events AS (SELECT /*+ RANGE_JOIN(b, 900 ) */ b.`TagName`, b.`EventTime`, a.window_start AS `WindowEventTime`, b.`Status`, b.`Value` FROM boundary_events b LEFT OUTER JOIN window_buckets a ON a.window_start <= b.`EventTime` AND a.window_end > b.`EventTime`) ,fill_status AS (SELECT *, last_value(`Status`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Status`, CASE WHEN `Fill_Status` <> "Bad" THEN `Value` ELSE null END AS `Good_Value` FROM window_events) ,fill_value AS (SELECT *, last_value(`Good_Value`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Value` FROM fill_status) ,fill_step AS (SELECT *, false AS Step FROM fill_value) ,interpolate AS (SELECT *, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_Fill_Value`, lead(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) AS `Next_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lead(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Next_Fill_Value`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN `Previous_Fill_Value` + ( (`Next_Fill_Value` - `Previous_Fill_Value`) * ( ( unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`) ) / ( unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`) ) ) ) ELSE NULL END AS `Interpolated_Value`, coalesce(`Interpolated_Value`, `Fill_Value`) as `Event_Value` FROM fill_step ),twa_calculations AS (SELECT `TagName`, `EventTime`, `WindowEventTime`, `Step`, `Status`, `Value`, `Previous_EventTime`, `Previous_Fill_Value`, `Next_EventTime`, `Next_Fill_Value`, `Interpolated_Value`, `Fill_Status`, `Fill_Value`, `Event_Value`, lead(`Fill_Status`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Status` , CASE WHEN `Next_Status` <> "Bad" OR (`Fill_Status` <> "Bad" AND `Next_Status` = "Bad") THEN lead(`Event_Value`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) ELSE `Value` END AS `Next_Value_For_Status` , CASE WHEN `Fill_Status` <> "Bad" THEN `Next_Value_For_Status` ELSE 0 END AS `Next_Value` , CASE WHEN `Fill_Status` <> "Bad" AND `Next_Status` <> "Bad" THEN ((cast(`Next_EventTime` AS double) - cast(`EventTime` AS double)) / 60) WHEN `Fill_Status` <> "Bad" AND `Next_Status` = "Bad" THEN ((cast(`Next_EventTime` AS integer) - cast(`EventTime` AS double)) / 60) ELSE 0 END AS good_minutes , CASE WHEN Step == false THEN ((`Event_Value` + `Next_Value`) * 0.5) * good_minutes ELSE (`Event_Value` * good_minutes) END AS twa_value FROM interpolate) ,twa AS (SELECT `TagName`, `WindowEventTime` AS `EventTime`, sum(twa_value) / sum(good_minutes) AS `Value` from twa_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT * FROM twa WHERE `EventTime` BETWEEN to_timestamp("2011-01-01T00:00:00") AND to_timestamp("2011-01-02T23:59:59")) ,pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` AS `TagName` FROM project) PIVOT (FIRST(`Value`) FOR `TagName` IN (\'mocked-TAGNAME\' AS `mocked-TAGNAME`))) SELECT * FROM pivot ORDER BY `EventTime` '
TWA_MOCKED_QUERY_METADATA = 'WITH raw_events AS (SELECT DISTINCT `TagName`, from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-02T23:59:59+00:00")), 1) AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000"), from_utc_timestamp(to_timestamp("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`) ,boundary_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) ,window_buckets AS (SELECT `EventTime` AS window_start, LEAD(`EventTime`) OVER (ORDER BY `EventTime`) AS window_end FROM (SELECT distinct `EventTime` FROM date_array) ) ,window_events AS (SELECT /*+ RANGE_JOIN(b, 900 ) */ b.`TagName`, b.`EventTime`, a.window_start AS `WindowEventTime`, b.`Status`, b.`Value` FROM boundary_events b LEFT OUTER JOIN window_buckets a ON a.window_start <= b.`EventTime` AND a.window_end > b.`EventTime`) ,fill_status AS (SELECT *, last_value(`Status`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Status`, CASE WHEN `Fill_Status` <> "Bad" THEN `Value` ELSE null END AS `Good_Value` FROM window_events) ,fill_value AS (SELECT *, last_value(`Good_Value`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Value` FROM fill_status)  ,fill_step AS (SELECT f.*, IFNULL(m.Step, false) AS Step FROM fill_value f LEFT JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` m ON f.`TagName` = m.`TagName`) ,interpolate AS (SELECT *, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_Fill_Value`, lead(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) AS `Next_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lead(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Next_Fill_Value`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN `Previous_Fill_Value` + ( (`Next_Fill_Value` - `Previous_Fill_Value`) * ( ( unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`) ) / ( unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`) ) ) ) ELSE NULL END AS `Interpolated_Value`, coalesce(`Interpolated_Value`, `Fill_Value`) as `Event_Value` FROM fill_step ),twa_calculations AS (SELECT `TagName`, `EventTime`, `WindowEventTime`, `Step`, `Status`, `Value`, `Previous_EventTime`, `Previous_Fill_Value`, `Next_EventTime`, `Next_Fill_Value`, `Interpolated_Value`, `Fill_Status`, `Fill_Value`, `Event_Value`, lead(`Fill_Status`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Status` , CASE WHEN `Next_Status` <> "Bad" OR (`Fill_Status` <> "Bad" AND `Next_Status` = "Bad") THEN lead(`Event_Value`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) ELSE `Value` END AS `Next_Value_For_Status` , CASE WHEN `Fill_Status` <> "Bad" THEN `Next_Value_For_Status` ELSE 0 END AS `Next_Value` , CASE WHEN `Fill_Status` <> "Bad" AND `Next_Status` <> "Bad" THEN ((cast(`Next_EventTime` AS double) - cast(`EventTime` AS double)) / 60) WHEN `Fill_Status` <> "Bad" AND `Next_Status` = "Bad" THEN ((cast(`Next_EventTime` AS integer) - cast(`EventTime` AS double)) / 60) ELSE 0 END AS good_minutes , CASE WHEN Step == false THEN ((`Event_Value` + `Next_Value`) * 0.5) * good_minutes ELSE (`Event_Value` * good_minutes) END AS twa_value FROM interpolate) ,twa AS (SELECT `TagName`, `WindowEventTime` AS `EventTime`, sum(twa_value) / sum(good_minutes) AS `Value` from twa_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT * FROM twa WHERE `EventTime` BETWEEN to_timestamp("2011-01-01T00:00:00") AND to_timestamp("2011-01-02T23:59:59")) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
TWA_MOCKED_QUERY_UOM = 'WITH raw_events AS (SELECT DISTINCT `TagName`, from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-02T23:59:59+00:00")), 1) AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT explode(sequence(from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000"), from_utc_timestamp(to_timestamp("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`) ,boundary_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) ,window_buckets AS (SELECT `EventTime` AS window_start, LEAD(`EventTime`) OVER (ORDER BY `EventTime`) AS window_end FROM (SELECT distinct `EventTime` FROM date_array) ) ,window_events AS (SELECT /*+ RANGE_JOIN(b, 900 ) */ b.`TagName`, b.`EventTime`, a.window_start AS `WindowEventTime`, b.`Status`, b.`Value` FROM boundary_events b LEFT OUTER JOIN window_buckets a ON a.window_start <= b.`EventTime` AND a.window_end > b.`EventTime`) ,fill_status AS (SELECT *, last_value(`Status`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Status`, CASE WHEN `Fill_Status` <> "Bad" THEN `Value` ELSE null END AS `Good_Value` FROM window_events) ,fill_value AS (SELECT *, last_value(`Good_Value`, true) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS `Fill_Value` FROM fill_status) ,fill_step AS (SELECT *, false AS Step FROM fill_value) ,interpolate AS (SELECT *, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lag(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Previous_Fill_Value`, lead(`EventTime`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) AS `Next_EventTime`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN lead(`Fill_Value`) OVER ( PARTITION BY `TagName` ORDER BY `EventTime` ) ELSE NULL END AS `Next_Fill_Value`, CASE WHEN `Step` = false AND `Status` IS NULL AND `Value` IS NULL THEN `Previous_Fill_Value` + ( (`Next_Fill_Value` - `Previous_Fill_Value`) * ( ( unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`) ) / ( unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`) ) ) ) ELSE NULL END AS `Interpolated_Value`, coalesce(`Interpolated_Value`, `Fill_Value`) as `Event_Value` FROM fill_step ),twa_calculations AS (SELECT `TagName`, `EventTime`, `WindowEventTime`, `Step`, `Status`, `Value`, `Previous_EventTime`, `Previous_Fill_Value`, `Next_EventTime`, `Next_Fill_Value`, `Interpolated_Value`, `Fill_Status`, `Fill_Value`, `Event_Value`, lead(`Fill_Status`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Status` , CASE WHEN `Next_Status` <> "Bad" OR (`Fill_Status` <> "Bad" AND `Next_Status` = "Bad") THEN lead(`Event_Value`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) ELSE `Value` END AS `Next_Value_For_Status` , CASE WHEN `Fill_Status` <> "Bad" THEN `Next_Value_For_Status` ELSE 0 END AS `Next_Value` , CASE WHEN `Fill_Status` <> "Bad" AND `Next_Status` <> "Bad" THEN ((cast(`Next_EventTime` AS double) - cast(`EventTime` AS double)) / 60) WHEN `Fill_Status` <> "Bad" AND `Next_Status` = "Bad" THEN ((cast(`Next_EventTime` AS integer) - cast(`EventTime` AS double)) / 60) ELSE 0 END AS good_minutes , CASE WHEN Step == false THEN ((`Event_Value` + `Next_Value`) * 0.5) * good_minutes ELSE (`Event_Value` * good_minutes) END AS twa_value FROM interpolate) ,twa AS (SELECT `TagName`, `WindowEventTime` AS `EventTime`, sum(twa_value) / sum(good_minutes) AS `Value` from twa_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT * FROM twa WHERE `EventTime` BETWEEN to_timestamp("2011-01-01T00:00:00") AND to_timestamp("2011-01-02T23:59:59")) SELECT p.`EventTime`, p.`TagName`, p.`Value`, m.`UoM` FROM project p LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` m ON p.`TagName` = m.`TagName` ORDER BY `TagName`, `EventTime` '

# Interpolation at Time
IAT_MOCKED_QUERY = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN  date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1)  AND `TagName` IN (\'mocked-TAGNAME\') ) , date_array AS (SELECT explode(array(  from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")   )) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`)  , interpolation_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, a.`EventTime` AS `Requested_EventTime`, b.`EventTime` AS `Found_EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN  raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) , interpolation_calculations AS (SELECT *, lag(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, lag(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_Value`, lead(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_EventTime`, lead(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Value`, CASE WHEN `Requested_EventTime` = `Found_EventTime` THEN `Value` WHEN `Next_EventTime` IS NULL THEN `Previous_Value` WHEN `Previous_EventTime` IS NULL AND `Next_EventTime` IS NULL THEN NULL ELSE `Previous_Value` + ((`Next_Value` - `Previous_Value`) * ((unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`)) / (unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`)))) END AS `Interpolated_Value` FROM interpolation_events) ,project AS (SELECT `TagName`, `EventTime`, `Interpolated_Value` AS `Value` FROM interpolation_calculations WHERE `EventTime` IN ( from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")  ) ) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
IAT_MOCKED_QUERY_CHECK_TAGS = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN  date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1)  AND UPPER(`TagName`) IN (\'MOCKED-TAGNAME\') ) , date_array AS (SELECT DISTINCT explode(array( from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")   )) AS `EventTime`, explode(array(`TagName`)) AS `TagName` FROM raw_events) , interpolation_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, a.`EventTime` AS `Requested_EventTime`, b.`EventTime` AS `Found_EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN  raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) , interpolation_calculations AS (SELECT *, lag(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, lag(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_Value`, lead(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_EventTime`, lead(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Value`, CASE WHEN `Requested_EventTime` = `Found_EventTime` THEN `Value` WHEN `Next_EventTime` IS NULL THEN `Previous_Value` WHEN `Previous_EventTime` IS NULL AND `Next_EventTime` IS NULL THEN NULL ELSE `Previous_Value` + ((`Next_Value` - `Previous_Value`) * ((unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`)) / (unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`)))) END AS `Interpolated_Value` FROM interpolation_events) ,project AS (SELECT `TagName`, `EventTime`, `Interpolated_Value` AS `Value` FROM interpolation_calculations WHERE `EventTime` IN ( from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")  ) ) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
IAT_MOCKED_QUERY_PIVOT = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN  date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1)  AND `TagName` IN (\'mocked-TAGNAME\') ) , date_array AS (SELECT explode(array(  from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")   )) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`)  , interpolation_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, a.`EventTime` AS `Requested_EventTime`, b.`EventTime` AS `Found_EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN  raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) , interpolation_calculations AS (SELECT *, lag(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, lag(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_Value`, lead(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_EventTime`, lead(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Value`, CASE WHEN `Requested_EventTime` = `Found_EventTime` THEN `Value` WHEN `Next_EventTime` IS NULL THEN `Previous_Value` WHEN `Previous_EventTime` IS NULL AND `Next_EventTime` IS NULL THEN NULL ELSE `Previous_Value` + ((`Next_Value` - `Previous_Value`) * ((unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`)) / (unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`)))) END AS `Interpolated_Value` FROM interpolation_events) ,project AS (SELECT `TagName`, `EventTime`, `Interpolated_Value` AS `Value` FROM interpolation_calculations WHERE `EventTime` IN ( from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")  ) ) ,pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` AS `TagName` FROM project) PIVOT (FIRST(`Value`) FOR `TagName` IN (\'mocked-TAGNAME\' AS `mocked-TAGNAME`))) SELECT * FROM pivot ORDER BY `EventTime` '
IAT_MOCKED_QUERY_UOM = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE to_date(`EventTime`) BETWEEN  date_sub(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1) AND date_add(to_date(to_timestamp("2011-01-01T00:00:00+00:00")), 1)  AND `TagName` IN (\'mocked-TAGNAME\') ) , date_array AS (SELECT explode(array(  from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")   )) AS `EventTime`, explode(array(\'mocked-TAGNAME\')) AS `TagName`)  , interpolation_events AS (SELECT coalesce(a.`TagName`, b.`TagName`) AS `TagName`, coalesce(a.`EventTime`, b.`EventTime`) AS `EventTime`, a.`EventTime` AS `Requested_EventTime`, b.`EventTime` AS `Found_EventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN  raw_events b ON a.`EventTime` = b.`EventTime` AND a.`TagName` = b.`TagName`) , interpolation_calculations AS (SELECT *, lag(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, lag(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_Value`, lead(`Found_EventTime`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_EventTime`, lead(`Value`) IGNORE NULLS OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Next_Value`, CASE WHEN `Requested_EventTime` = `Found_EventTime` THEN `Value` WHEN `Next_EventTime` IS NULL THEN `Previous_Value` WHEN `Previous_EventTime` IS NULL AND `Next_EventTime` IS NULL THEN NULL ELSE `Previous_Value` + ((`Next_Value` - `Previous_Value`) * ((unix_timestamp(`EventTime`) - unix_timestamp(`Previous_EventTime`)) / (unix_timestamp(`Next_EventTime`) - unix_timestamp(`Previous_EventTime`)))) END AS `Interpolated_Value` FROM interpolation_events) ,project AS (SELECT `TagName`, `EventTime`, `Interpolated_Value` AS `Value` FROM interpolation_calculations WHERE `EventTime` IN ( from_utc_timestamp(to_timestamp("2011-01-01T00:00:00+00:00"), "+0000")  ) ) SELECT p.`EventTime`, p.`TagName`, p.`Value`, m.`UoM` FROM project p LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` m ON p.`TagName` = m.`TagName` ORDER BY `TagName`, `EventTime` '

# Metadata
METADATA_MOCKED_QUERY = "SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata`  WHERE `TagName` IN ('mocked-TAGNAME') ORDER BY `TagName` "
METADATA_MOCKED_QUERY_CHECK_TAGS = "SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata`  WHERE UPPER(`TagName`) IN ('MOCKED-TAGNAME') ORDER BY `TagName` "
METADATA_MOCKED_QUERY_NO_TAGS = "SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` ORDER BY `TagName` "

# Circular Average
CIRCULAR_AVERAGE_MOCKED_QUERY = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(\'mocked-TAGNAME\')) AS `TagName`) ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, (Circular_Average_Value_in_Radians * (360 - 0)) / (2*pi())+ 0 AS Circular_Average_Value_in_Degrees FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Average_Value_in_Degrees AS `Value` FROM circular_average_results) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
CIRCULAR_AVERAGE_MOCKED_QUERY_CHECK_TAGS = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND UPPER(`TagName`) IN (\'MOCKED-TAGNAME\') ) ,date_array AS (SELECT DISTINCT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(`TagName`)) AS `TagName` FROM raw_events)  ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, (Circular_Average_Value_in_Radians * (360 - 0)) / (2*pi())+ 0 AS Circular_Average_Value_in_Degrees FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Average_Value_in_Degrees AS `Value` FROM circular_average_results) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
CIRCULAR_AVERAGE_MOCKED_QUERY_PIVOT = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(\'mocked-TAGNAME\')) AS `TagName`) ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, (Circular_Average_Value_in_Radians * (360 - 0)) / (2*pi())+ 0 AS Circular_Average_Value_in_Degrees FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Average_Value_in_Degrees AS `Value` FROM circular_average_results) ,pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` AS `TagName` FROM project) PIVOT (FIRST(`Value`) FOR `TagName` IN (\'mocked-TAGNAME\' AS `mocked-TAGNAME`))) SELECT * FROM pivot ORDER BY `EventTime` '
CIRCULAR_AVERAGE_MOCKED_QUERY_UOM = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(\'mocked-TAGNAME\')) AS `TagName`) ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, (Circular_Average_Value_in_Radians * (360 - 0)) / (2*pi())+ 0 AS Circular_Average_Value_in_Degrees FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Average_Value_in_Degrees AS `Value` FROM circular_average_results) SELECT p.*, m.`UoM` FROM project p LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` m ON p.`TagName` = m.`TagName` ORDER BY `TagName`, `EventTime` '

# Circular Standard Deviations
CIRCULAR_SD_MOCKED_QUERY = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(\'mocked-TAGNAME\')) AS `TagName`) ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, SQRT(-2*LN(R)) * ( 360 - 0) / (2*PI()) AS Circular_Standard_Deviation FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Standard_Deviation AS `Value` FROM circular_average_results) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
CIRCULAR_SD_MOCKED_QUERY_CHECK_TAGS = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND UPPER(`TagName`) IN (\'MOCKED-TAGNAME\') ) ,date_array AS (SELECT DISTINCT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(`TagName`)) AS `TagName` FROM raw_events)  ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, SQRT(-2*LN(R)) * ( 360 - 0) / (2*PI()) AS Circular_Standard_Deviation FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Standard_Deviation AS `Value` FROM circular_average_results) SELECT * FROM project ORDER BY `TagName`, `EventTime` '
CIRCULAR_SD_MOCKED_QUERY_PIVOT = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(\'mocked-TAGNAME\')) AS `TagName`) ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, SQRT(-2*LN(R)) * ( 360 - 0) / (2*PI()) AS Circular_Standard_Deviation FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Standard_Deviation AS `Value` FROM circular_average_results) ,pivot AS (SELECT * FROM (SELECT `EventTime`, `Value`, `TagName` AS `TagName` FROM project) PIVOT (FIRST(`Value`) FOR `TagName` IN (\'mocked-TAGNAME\' AS `mocked-TAGNAME`))) SELECT * FROM pivot ORDER BY `EventTime` '
CIRCULAR_SD_MOCKED_QUERY_UOM = 'WITH raw_events AS (SELECT DISTINCT from_utc_timestamp(date_trunc("millisecond",`EventTime`), "+0000") AS `EventTime`, `TagName`,  `Status`,  `Value` FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN TO_TIMESTAMP("2011-01-01T00:00:00+00:00") AND TO_TIMESTAMP("2011-01-02T23:59:59+00:00") AND `TagName` IN (\'mocked-TAGNAME\') ) ,date_array AS (SELECT EXPLODE(SEQUENCE(FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-01T00:00:00+00:00"), "+0000"), FROM_UTC_TIMESTAMP(TO_TIMESTAMP("2011-01-02T23:59:59+00:00"), "+0000"), INTERVAL \'15 minute\')) AS `EventTime`, EXPLODE(ARRAY(\'mocked-TAGNAME\')) AS `TagName`) ,window_events AS (SELECT COALESCE(a.`TagName`, b.`TagName`) AS `TagName`, COALESCE(a.`EventTime`, b.`EventTime`) AS `EventTime`, WINDOW(COALESCE(a.`EventTime`, b.`EventTime`), \'15 minute\').START `WindowEventTime`, b.`Status`, b.`Value` FROM date_array a FULL OUTER JOIN raw_events b ON CAST(a.`EventTime` AS LONG) = CAST(b.`EventTime` AS LONG) AND a.`TagName` = b.`TagName`) ,calculation_set_up AS (SELECT `EventTime`, `WindowEventTime`, `TagName`, `Value`, MOD(`Value` - 0, (360 - 0))*(2*pi()/(360 - 0)) AS `Value_in_Radians`, LAG(`EventTime`) OVER (PARTITION BY `TagName` ORDER BY `EventTime`) AS `Previous_EventTime`, (unix_millis(`EventTime`) - unix_millis(`Previous_EventTime`)) / 86400000 AS Time_Difference, COS(`Value_in_Radians`) AS Cos_Value, SIN(`Value_in_Radians`) AS Sin_Value FROM window_events) ,circular_average_calculations AS (SELECT `WindowEventTime`, `TagName`, Time_Difference, AVG(Cos_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Cos, AVG(Sin_Value) OVER (PARTITION BY `TagName` ORDER BY `EventTime` ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS Average_Sin, SQRT(POW(Average_Cos, 2) + POW(Average_Sin, 2)) AS Vector_Length, Average_Cos/Vector_Length AS Rescaled_Average_Cos, Average_Sin/Vector_Length AS Rescaled_Average_Sin, Time_Difference * Rescaled_Average_Cos AS Diff_Average_Cos, Time_Difference * Rescaled_Average_Sin AS Diff_Average_Sin FROM calculation_set_up)  ,circular_average_results AS (SELECT `WindowEventTime` AS `EventTime`, `TagName`, sum(Diff_Average_Cos)/sum(Time_Difference) AS Cos_Time_Averages, sum(Diff_Average_Sin)/sum(Time_Difference) AS Sin_Time_Averages, array_min(array(1, sqrt(pow(Cos_Time_Averages, 2) + pow(Sin_Time_Averages, 2)))) AS R, mod(2*pi() + atan2(Sin_Time_Averages, Cos_Time_Averages), 2*pi()) AS Circular_Average_Value_in_Radians, SQRT(-2*LN(R)) * ( 360 - 0) / (2*PI()) AS Circular_Standard_Deviation FROM circular_average_calculations GROUP BY `TagName`, `WindowEventTime`) ,project AS (SELECT `EventTime`, `TagName`, Circular_Standard_Deviation AS `Value` FROM circular_average_results) SELECT p.*, m.`UoM` FROM project p LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` m ON p.`TagName` = m.`TagName` ORDER BY `TagName`, `EventTime` '

# Latest
LATEST_MOCKED_QUERY = "WITH latest AS (SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_latest`  WHERE `TagName` IN ('mocked-TAGNAME') ORDER BY `TagName` ) SELECT * FROM latest "
LATEST_MOCKED_QUERY_CHECK_TAGS = "WITH latest AS (SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_latest`  WHERE UPPER(`TagName`) IN ('MOCKED-TAGNAME') ORDER BY `TagName` ) SELECT * FROM latest "
LATEST_MOCKED_QUERY_NO_TAGS = "WITH latest AS (SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_latest` ORDER BY `TagName` ) SELECT * FROM latest "
LATEST_MOCKED_QUERY_UOM = "WITH latest AS (SELECT * FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_latest`  WHERE `TagName` IN ('mocked-TAGNAME') ORDER BY `TagName` ) SELECT l.*, m.`UoM` FROM latest l LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` m ON l.`TagName` = m.`TagName` "

# Summary
SUMMARY_MOCKED_QUERY = "WITH summary AS (SELECT `TagName`,  count(`Value`) as Count, CAST(Avg(`Value`) as decimal(10, 2)) as Avg, CAST(Min(`Value`) as decimal(10, 2)) as Min, CAST(Max(`Value`) as decimal(10, 2)) as Max, CAST(stddev(`Value`) as decimal(10, 2)) as StDev, CAST(sum(`Value`) as decimal(10, 2)) as Sum, CAST(variance(`Value`) as decimal(10, 2)) as Var FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME') GROUP BY `TagName`) SELECT * FROM summary"
SUMMARY_MOCKED_QUERY_CHECK_TAGS = "WITH summary AS (SELECT `TagName`,  count(`Value`) as Count, CAST(Avg(`Value`) as decimal(10, 2)) as Avg, CAST(Min(`Value`) as decimal(10, 2)) as Min, CAST(Max(`Value`) as decimal(10, 2)) as Max, CAST(stddev(`Value`) as decimal(10, 2)) as StDev, CAST(sum(`Value`) as decimal(10, 2)) as Sum, CAST(variance(`Value`) as decimal(10, 2)) as Var FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND UPPER(`TagName`) IN ('MOCKED-TAGNAME') GROUP BY `TagName`) SELECT * FROM summary"
SUMMARY_MOCKED_QUERY_UOM = "WITH summary AS (SELECT `TagName`,  count(`Value`) as Count, CAST(Avg(`Value`) as decimal(10, 2)) as Avg, CAST(Min(`Value`) as decimal(10, 2)) as Min, CAST(Max(`Value`) as decimal(10, 2)) as Max, CAST(stddev(`Value`) as decimal(10, 2)) as StDev, CAST(sum(`Value`) as decimal(10, 2)) as Sum, CAST(variance(`Value`) as decimal(10, 2)) as Var FROM `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_events_mocked-data-type` WHERE `EventTime` BETWEEN to_timestamp('2011-01-01T00:00:00+00:00') AND to_timestamp('2011-01-02T23:59:59+00:00') AND `TagName` IN ('mocked-TAGNAME') GROUP BY `TagName`), uom AS (SELECT summary.*, metadata.`UoM` FROM summary LEFT OUTER JOIN `mocked-buiness-unit`.`sensors`.`mocked-asset_mocked-data-security-level_metadata` AS metadata ON summary.`TagName` = metadata.`TagName`) SELECT * FROM uom"
